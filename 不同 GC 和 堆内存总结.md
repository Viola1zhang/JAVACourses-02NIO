# 不同 GC 和 堆内存总结

## GC 算法

- 标记-清除 （Mark And Sweep)。直接清除可回收对象，不进行压缩脆片，内存整理。优点：单次 STW 的时间可能要短一些。缺点：但是产生的内存碎片，可能导致内存总空间足够，但是没一块连续的空间存放对象的问题，内存利用率降低；对象放不下，可能触发额外的 GC。**适用对象存活率高的情况。老年代**

- 标记-复制（Mark-Copy)。优点：存活的对象越少，复制需要的空间就越小；而且复制后的对象们内存空间排布紧凑，避免空间碎片的问题。缺点：有一部分空间被浪费。如果存活对象大且多的话复制成本比较高。**适用每次 GC 存活对象小而美的情况。年轻代**

- 标记-清除-整理(Mark-Sweep-Compact)。STW 时间可能会稍长一些，内存碎片问题得到解决。适用对象存活率高的情况。

  

### Serial GC(串行GC)

- -XX:+UseSerialGC

- 串行 GC 单线程执行，CPU利用率高，在 GC 期间其他业务线程均暂停，暂停的时间长。

- 串行 GC 对年轻代采用标记复制算法。对老年代使用标记-清除-整理算法。

- 串行 GC 简单直接，在单核 CPU 环境下比较适用。
- 随着堆内存的增加, Young GC 的次数也逐渐增加。堆内存设置的越大，每次GC的时间越长

### Parallel GC（并行GC）

- -XX:UseParallelGC -XX:UseParallelOldGC

- 使用的 GC 算法和串行的一样。

- 适用于多核服务器, 默认值为CPU核心数，该收集器的目标更倾向于**提高系统吞吐量**，STW,有时候单次的 GC 暂停时间较长。

- Java 6,7,8默认并行GC
- 创建对象数量随着内存的大小，逐渐变大进而变小

### CMS GC

-XX:UseConcMarkSweepGC

对老年代没有整理操作，使用 free-list 进行内存空间的管理，未进行碎片清理。默认的核心线程数 CPU 核数 / 4。

可以和业务线程并发执行，GC 暂停时间少。

CMS中间过程会发生Young GC

若增大堆内存，有时只会发生Yong GC, 不会发生CMS GC

### G1 GC

- 将STW停顿的时间和分布，变成可预期和可配置的

- 打破整个分区的理论，把内存划分成多个小块进行管理。对每个小块的垃圾数量进行预估，优先回收垃圾多的 Region。可预期的垃圾停顿时间。
- 可设置GC 暂停得时间，默认是200。
- G1 GC 在并发模式失败，晋升失败和巨型对象分配失败的情况下会导致退化。
- 增加堆内存大小可以较少GC退化

### 总结：

- 堆内存越大，内存中可容纳的对象越多，GC 的次数随之减少，单次 GC 的暂停时间可能更长（取决于存活对象的数量）。

- CMS 在于并发执行，提高系统响应。Parallel 更倾向于提高吞吐量；G1 GC 倾向于可配置可预估的暂停时间。
- CMS - 老年代 没有整理，使用 free-list 管理回收内存；真正的 STW 时间小，但是步骤多，还有浮动垃圾，GC 退化问题。G1 GC 也存在 GC 退化问题。

